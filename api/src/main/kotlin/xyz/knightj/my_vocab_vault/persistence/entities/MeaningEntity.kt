package xyz.knightj.my_vocab_vault.persistence.entitiesimport jakarta.annotation.Nullableimport jakarta.persistence.*import xyz.knightj.my_vocab_vault.models.MeaningDetailsimport xyz.knightj.my_vocab_vault.models.PartsOfSpeechimport java.util.*@Entity@Table(name = "meanings")class MeaningEntity {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    var id: Long? = null    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumns(        JoinColumn(name = "wordName", referencedColumnName = "wordName"),        JoinColumn(name = "userId", referencedColumnName = "userId")    )    var word: WordEntity? = null    var partsOfSpeech: String? = null    var definition: String? = null    @get:Nullable    @ElementCollection    @Nullable    var examples: Set<String>? = null    constructor()    constructor(        id: Long?,        word: WordEntity?,        partsOfSpeech: String?,        definition: String?,        @Nullable examples: Set<String>?    ) {        this.id = id        this.word = word        this.partsOfSpeech = partsOfSpeech        this.definition = definition        this.examples = examples    }    override fun equals(o: Any?): Boolean {        if (this === o) return true        return if (o !is MeaningEntity) false else id == o.id && word == o.word && partsOfSpeech == o.partsOfSpeech && definition == o.definition && examples == o.examples    }    override fun hashCode(): Int {        return Objects.hash(id, word, partsOfSpeech, definition, examples)    }}fun List<MeaningEntity>.convertEntityToMeaningDetails(): MutableList<MeaningDetails>{    return this.map { entity -> MeaningDetails(        id = entity.id.toString(),        partsOfSpeech = entity.partsOfSpeech?.let { PartsOfSpeech.valueOf(it) },        definition = entity.definition,        examples = entity.examples?.toMutableSet()    )    }.toMutableList()}