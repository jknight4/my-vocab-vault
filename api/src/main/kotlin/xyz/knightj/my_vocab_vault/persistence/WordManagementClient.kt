package xyz.knightj.my_vocab_vault.persistenceimport org.springframework.stereotype.Componentimport xyz.knightj.my_vocab_vault.models.*import xyz.knightj.my_vocab_vault.persistence.entities.*import xyz.knightj.my_vocab_vault.persistence.repositories.WordRepositoryimport java.time.Instant@Componentclass WordManagementClient(private val wordRepository: WordRepository) {    fun saveNewWord(userId: String, word: WordRequestData) {        val key = WordEntityKey(userId, word.word.uppercase())        val meaning: MeaningEntity = MeaningEntity().apply {            partsOfSpeech = word.partsOfSpeech.name            definition = word.definition            examples = word.examples?.toSet()        }        if(wordRepository.existsById(key)){            // update function            println("Word already exists in DB")        } else {            val entity: WordEntity = WordEntity().apply {                this.wordId = key                this.meanings = mutableListOf(meaning)                this.tags = word.tags?.toSet()                this.createdAt = Instant.now().toString()                this.updatedAt = null            }            meaning.word = entity            wordRepository.save(entity)        }    }    fun findAllWords(userId: String): List<WordDetails> {        return wordRepository.findByUserIdWithDetails(userId)            ?.map { wordEntity ->                wordEntity.convertEntityToWordDetails() }            ?: emptyList()    }    fun deleteWord(userId: String, wordName: String){        val key = WordEntityKey(userId, wordName.uppercase())        wordRepository.deleteById(key)    }    fun findWord(userId: String, wordName: String): WordDetails? {        val word: WordEntity = wordRepository.findWordWithMeanings(userId, wordName.uppercase()) ?: return null        word.tags = wordRepository.findWordWithTags(userId, wordName.uppercase())?.tags        return word.convertEntityToWordDetails()    }    fun editTags(userId: String, wordName: String, tags: Set<String>){        val word: WordEntity =            wordRepository.findWordWithTags(userId, wordName.uppercase())                ?.apply {                    this.tags = tags                    this.updatedAt = Instant.now().toString()                }            ?: throw IllegalArgumentException("Not Found")        wordRepository.save(word)    }}