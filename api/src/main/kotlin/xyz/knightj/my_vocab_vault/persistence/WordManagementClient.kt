package xyz.knightj.my_vocab_vault.persistenceimport org.springframework.stereotype.Componentimport xyz.knightj.my_vocab_vault.models.*import xyz.knightj.my_vocab_vault.persistence.entities.MeaningEntityimport xyz.knightj.my_vocab_vault.persistence.entities.WordEntityimport xyz.knightj.my_vocab_vault.persistence.entities.WordEntityKeyimport xyz.knightj.my_vocab_vault.persistence.entities.convertToMeaningDetailsimport xyz.knightj.my_vocab_vault.persistence.repositories.MeaningRepositoryimport xyz.knightj.my_vocab_vault.persistence.repositories.WordRepositoryimport java.time.Instant@Componentclass WordManagementClient(private val wordRepository: WordRepository) {    fun saveNewWord(userId: String, word: WordRequestData) {        val key = WordEntityKey(userId, word.word.uppercase())        val meaning: MeaningEntity = MeaningEntity().apply {            partsOfSpeech = word.partsOfSpeech.name            definition = word.definition            examples = word.examples?.toSet()        }        if(wordRepository.existsById(key)){            // update function            println("Word already exists in DB")        } else {            val entity: WordEntity = WordEntity().apply {                this.wordId = key                this.meanings = mutableListOf(meaning)                this.tags = word.tags?.toSet()                this.createdAt = Instant.now().toString()                this.updatedAt = null            }            meaning.word = entity            wordRepository.save(entity)        }    }//    fun findAllWords(userId: String): List<WordDetails> {//        val words : List<Word> = getAllWordsByUserId(userId)////        return words.map {//            word ->//            val meanings: List<Meaning> = getAllMeaningsByWordId(word.id)////            WordDetails(//                word = word.wordName,//                meanings = meanings.convertToDetails())//        }////    }    fun findWord(userId: String, wordName: String): WordDetails? {        val word: WordEntity = wordRepository.findWordWithDetails(userId, wordName.uppercase()) ?: return null        return WordDetails(word = wordName,            tags = word.tags?.toMutableSet(),            meanings = word.meanings.convertToMeaningDetails(),            createdAt = word.createdAt,            updatedAt = word.updatedAt)    }//    private fun getAllWordsByUserId(userId: String): List<Word> {//        return wordRepository.findByUserId(userId)//    }//    private fun getAllMeaningsByUserId(userId: String): List<Meaning>{//        return meaningRepository.findByUserId(userId)//    }//    private fun getAllMeaningsByWordId(wordId: String): List<Meaning>{//        return meaningRepository.findByWordId(wordId)//    }}