package xyz.knightj.my_vocab_vault.controllerimport org.springframework.http.HttpStatusimport org.springframework.http.ResponseEntityimport org.springframework.web.bind.annotation.CrossOriginimport org.springframework.web.bind.annotation.GetMappingimport org.springframework.web.bind.annotation.PostMappingimport org.springframework.web.bind.annotation.RequestBodyimport org.springframework.web.bind.annotation.RequestHeaderimport org.springframework.web.bind.annotation.RequestMappingimport org.springframework.web.bind.annotation.RestControllerimport xyz.knightj.my_vocab_vault.domain.Meaningimport xyz.knightj.my_vocab_vault.domain.PartsOfSpeechimport xyz.knightj.my_vocab_vault.domain.WordDataimport xyz.knightj.my_vocab_vault.domain.WordDetailsimport xyz.knightj.my_vocab_vault.service.WordManagementService@RestController@RequestMapping("/api/word-management")@CrossOrigin(origins = ["http://localhost:5173"])class WordManagementController(private val wordManagementService: WordManagementService) {    @GetMapping("/words")    fun getAllWords(@RequestHeader headers: Map<String, String>): ResponseEntity<List<WordDetails>> {        // headerValidator.validate(headers)        val retrievedWords: List<WordDetails> = wordManagementService.getAllWords();        return ResponseEntity.ok().body(            listOf(            WordDetails("123", "123", "Word",            Meaning(PartsOfSpeech.ADVERB, "Test"),            mutableListOf("Test") )))    }    @PostMapping("/word")    fun saveWord(@RequestHeader headers: Map<String, String>, @RequestBody wordData: WordData): ResponseEntity<Void> {        // validate header / request        val wasSuccessful = wordManagementService.saveWord(wordData)        return if(wasSuccessful) ResponseEntity.status(HttpStatus.CREATED).build()        else ResponseEntity.status(HttpStatus.CONFLICT).build()    }}